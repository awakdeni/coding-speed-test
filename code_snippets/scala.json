[
    "def quickSort[T](arr: List[T])(implicit ord: Ordering[T]): List[T] = {\n  import ord._\n  \n  arr match {\n    case Nil => Nil\n    case head :: tail =>\n      val (smaller, larger) = tail.partition(_ < head)\n      quickSort(smaller) ::: head :: quickSort(larger)\n  }\n}",
    "class BinaryTree[T](val value: T, var left: Option[BinaryTree[T]] = None, var right: Option[BinaryTree[T]] = None) {\n  \n  def insert(newValue: T)(implicit ord: Ordering[T]): Unit = {\n    import ord._\n    \n    if (newValue < value) {\n      left match {\n        case None => left = Some(new BinaryTree(newValue))\n        case Some(node) => node.insert(newValue)\n      }\n    } else {\n      right match {\n        case None => right = Some(new BinaryTree(newValue))\n        case Some(node) => node.insert(newValue)\n      }\n    }\n  }\n}",
    "trait Animal {\n  def name: String\n  def sound: String\n  \n  def makeSound(): String = s\"$name says $sound\"\n}\n\ncase class Dog(name: String) extends Animal {\n  val sound = \"Woof!\"\n}\n\ncase class Cat(name: String) extends Animal {\n  val sound = \"Meow!\"\n}\n\nobject AnimalSounds {\n  def main(args: Array[String]): Unit = {\n    val animals = List(Dog(\"Buddy\"), Cat(\"Whiskers\"))\n    animals.foreach(animal => println(animal.makeSound()))\n  }\n}",
    "import scala.concurrent.{Future, ExecutionContext}\nimport scala.util.{Success, Failure}\n\nclass AsyncProcessor(implicit ec: ExecutionContext) {\n  \n  def processData(data: List[Int]): Future[List[Int]] = {\n    Future {\n      data.map(_ * 2).filter(_ > 10)\n    }\n  }\n  \n  def handleResult(future: Future[List[Int]]): Unit = {\n    future.onComplete {\n      case Success(result) => println(s\"Processing completed: $result\")\n      case Failure(exception) => println(s\"Processing failed: ${exception.getMessage}\")\n    }\n  }\n}",
    "object FunctionalProgramming {\n  \n  def fibonacci(n: BigInt): BigInt = {\n    @annotation.tailrec\n    def fibHelper(i: BigInt, a: BigInt, b: BigInt): BigInt = {\n      if (i == 0) a\n      else fibHelper(i - 1, b, a + b)\n    }\n    \n    fibHelper(n, 0, 1)\n  }\n  \n  def factorial(n: BigInt): BigInt = {\n    if (n <= 1) 1\n    else n * factorial(n - 1)\n  }\n  \n  def isPrime(n: Int): Boolean = {\n    if (n <= 1) false\n    else if (n <= 3) true\n    else if (n % 2 == 0 || n % 3 == 0) false\n    else {\n      var i = 5\n      while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0) return false\n        i += 6\n      }\n      true\n    }\n  }\n}"
]