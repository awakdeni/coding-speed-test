[
    "fn bubble_sort<T: Ord>(arr: &mut [T]) {\n    let n = arr.len();\n    for i in 0..n {\n        for j in 0..n-i-1 {\n            if arr[j] > arr[j+1] {\n                arr.swap(j, j+1);\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [64, 34, 25, 12, 22, 11, 90];\n    bubble_sort(&mut numbers);\n    println!(\"Sorted array: {:?}\", numbers);\n}",
    "use std::fmt;\n\n#[derive(Debug)]\npub struct Node<T> {\n    data: T,\n    next: Option<Box<Node<T>>>,\n}\n\nimpl<T> Node<T> {\n    pub fn new(data: T) -> Self {\n        Node { data, next: None }\n    }\n}\n\n#[derive(Debug)]\npub struct LinkedList<T> {\n    head: Option<Box<Node<T>>>,\n    size: usize,\n}\n\nimpl<T> LinkedList<T> {\n    pub fn new() -> Self {\n        LinkedList { head: None, size: 0 }\n    }\n\n    pub fn push(&mut self, data: T) {\n        let mut new_node = Box::new(Node::new(data));\n        new_node.next = self.head.take();\n        self.head = Some(new_node);\n        self.size += 1;\n    }\n}",
    "fn binary_search(arr: &[i32], target: i32) -> Option<usize> {\n    let mut left = 0;\n    let mut right = arr.len();\n\n    while left < right {\n        let mid = left + (right - left) / 2;\n        match arr[mid].cmp(&target) {\n            std::cmp::Ordering::Equal => return Some(mid),\n            std::cmp::Ordering::Less => left = mid + 1,\n            std::cmp::Ordering::Greater => right = mid,\n        }\n    }\n    None\n}\n\nfn merge_sort(arr: &mut [i32]) {\n    if arr.len() > 1 {\n        let mid = arr.len() / 2;\n        merge_sort(&mut arr[..mid]);\n        merge_sort(&mut arr[mid..]);\n        merge(arr, mid);\n    }\n}\n\nfn merge(arr: &mut [i32], mid: usize) {\n    // Implementation omitted for brevity\n    // Would create temporary vectors and merge them\n}",
    "struct DynamicArray<T> {\n    data: Vec<T>,\n    capacity: usize,\n}\n\nimpl<T> DynamicArray<T> {\n    fn new(initial_capacity: usize) -> Self {\n        DynamicArray {\n            data: Vec::with_capacity(initial_capacity),\n            capacity: initial_capacity,\n        }\n    }\n\n    fn push(&mut self, item: T) {\n        if self.data.len() >= self.capacity {\n            self.resize();\n        }\n        self.data.push(item);\n    }\n\n    fn resize(&mut self) {\n        self.capacity *= 2;\n        let mut new_data = Vec::with_capacity(self.capacity);\n        new_data.extend(self.data.drain(..));\n        self.data = new_data;\n    }\n\n    fn pop(&mut self) -> Option<T> {\n        self.data.pop()\n    }\n}",
    "fn is_palindrome(s: &str) -> bool {\n    let filtered: String = s.chars()\n        .filter(|c| c.is_ascii_alphanumeric())\n        .map(|c| c.to_ascii_lowercase())\n        .collect();\n    \n    filtered.chars().eq(filtered.chars().rev())\n}\n\nfn reverse_string(s: &str) -> String {\n    s.chars().rev().collect()\n}\n\nfn count_words(s: &str) -> usize {\n    s.split_whitespace().count()\n}\n\nfn main() {\n    let test_str = \"A man, a plan, a canal: Panama\";\n    println!(\"Is palindrome: {}\", is_palindrome(test_str));\n    println!(\"Reversed: {}\", reverse_string(test_str));\n    println!(\"Word count: {}\", count_words(test_str));\n}",
    "struct Book {\n    title: String,\n    pages: u32,\n}\n\nfn print_book(book: &Book) {\n    println!(\"Book: {} ({} pages)\", book.title, book.pages);\n}\n\nfn main() {\n    let book = Book {\n        title: String::from(\"The Rust Programming Language\"),\n        pages: 519,\n    };\n    \n    // Borrow immutably\n    print_book(&book);\n    \n    // Can still use book after immutable borrow\n    println!(\"Original title: {}\", book.title);\n    \n    // Mutable borrow example\n    let mut mutable_book = book;\n    mutable_book.title = String::from(\"Rust in Action\");\n    print_book(&mutable_book);\n}",
    "trait Greet {\n    fn greet(&self) -> String;\n}\n\nstruct Person {\n    name: String,\n    age: u8,\n}\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, my name is {} and I'm {} years old.\", self.name, self.age)\n    }\n}\n\nfn main() {\n    let person = Person {\n        name: String::from(\"Alice\"),\n        age: 30,\n    };\n    \n    println!(\"{}\", person.greet());\n    \n    // Trait objects\n    let greeters: Vec<&dyn Greet> = vec![&person];\n    for greeter in greeters {\n        println!(\"{}\", greeter.greet());\n    }\n}"
]